var areaJSON='{"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[4.09108, 3.06556, 1.37261, 0.583658, 0.892857], "total":[3359, 3008, 3, 1], "name":"System", "max_resources":[109572, 219144, 514, 112], "children":[{"name":"avg", "compute_units":1, "type":"function", "total_percent":[4.09108, 3.06556, 1.37261, 0.583658, 0.892857], "total_kernel_resources":[3359, 3008, 3, 1], "details":[{"type":"text", "text":"Number of compute units: 1"}], "children":[{"name":"Component call", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 128 bits wide with a buffer size of 0 elements."}]}, {"name":"Component return", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}]}, {"name":"Variable: \\n - \'i\' (avg.c:8)", "type":"resource", "data":[7, 36, 0, 0], "debug":[[{"filename":"avg.c", "line":8}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"Variable: \\n - \'j\' (avg.c:8)", "type":"resource", "data":[40, 27, 0, 0], "debug":[[{"filename":"avg.c", "line":8}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 16 (depth was increased by a factor of 16 due to a loop initiation interval of 16.)"}]}, {"name":"Variable: \\n - \'sum\' (avg.c:9)", "type":"resource", "data":[96, 93, 0, 0], "debug":[[{"filename":"avg.c", "line":9}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 16 (depth was increased by a factor of 16 due to a loop initiation interval of 16.)"}]}, {"name":"avg.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[0, 128, 0, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[0, 128, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[5, 2, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[5, 2, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[1, 0, 0, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Channel Read", "type":"resource", "count":1, "data":[1, 0, 0, 0]}]}]}]}, {"name":"avg.B2", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[28, 55, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0]}, {"name":"avg.c:12", "type":"resource", "data":[17.3333, 47.3333, 0, 0], "debug":[[{"filename":"avg.c", "line":12}]]}, {"name":"avg.c:23", "type":"resource", "data":[5, 2, 0, 0], "debug":[[{"filename":"avg.c", "line":23}]]}, {"name":"avg.c:24", "type":"resource", "data":[4.66667, 5.66667, 0, 0], "debug":[[{"filename":"avg.c", "line":24}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[103, 50, 0, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"avg.c:12", "type":"resource", "data":[37.6667, 0, 0, 0], "debug":[[{"filename":"avg.c", "line":12}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"6-bit Integer Add", "type":"resource", "count":2, "data":[4.66667, 0, 0, 0]}], "replace_name":"true"}, {"name":"avg.c:24", "type":"resource", "data":[2.33333, 0, 0, 0], "debug":[[{"filename":"avg.c", "line":24}]], "children":[{"name":"6-bit Integer Add", "type":"resource", "count":1, "data":[2.33333, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"avg.B3", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[236, 363, 0, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[236, 363, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[365, 374, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[97, 93, 0, 0]}, {"name":"avg.c:12", "type":"resource", "data":[125, 129, 0, 0], "debug":[[{"filename":"avg.c", "line":12}]]}, {"name":"avg.c:14", "type":"resource", "data":[0.5, 0, 0, 0], "debug":[[{"filename":"avg.c", "line":14}]]}, {"name":"avg.c:16", "type":"resource", "data":[107, 107, 0, 0], "debug":[[{"filename":"avg.c", "line":16}]]}, {"name":"avg.c:20", "type":"resource", "data":[0.5, 0, 0, 0], "debug":[[{"filename":"avg.c", "line":20}]]}, {"name":"avg.c:23", "type":"resource", "data":[21, 27, 0, 0], "debug":[[{"filename":"avg.c", "line":23}]]}, {"name":"avg.c:24", "type":"resource", "data":[14, 18, 0, 0], "debug":[[{"filename":"avg.c", "line":24}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[368, 159, 0, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1027, 749, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Floating-point Add", "type":"resource", "count":1, "data":[995, 717, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[32, 32, 0, 0]}]}, {"name":"avg.c:16", "type":"resource", "data":[38, 0, 0, 0], "debug":[[{"filename":"avg.c", "line":16}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"4-bit Integer Add", "type":"resource", "count":2, "data":[5, 0, 0, 0]}], "replace_name":"true"}, {"name":"avg.c:18", "type":"resource", "data":[33, 0, 0, 0], "debug":[[{"filename":"avg.c", "line":18}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}], "replace_name":"true"}, {"name":"avg.c:19", "type":"resource", "data":[35, 1, 0, 0], "debug":[[{"filename":"avg.c", "line":19}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[35, 1, 0, 0]}], "replace_name":"true"}, {"name":"avg.c:20", "type":"resource", "data":[249, 221, 2, 0], "debug":[[{"filename":"avg.c", "line":20}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[249, 221, 2, 0], "details":[{"type":"text", "text":"Load uses a Local-pipelined LSU"}]}], "replace_name":"true"}]}]}, {"name":"avg.B4", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[22, 43, 0, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[22, 43, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[25, 19, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"avg.c:23", "type":"resource", "data":[25, 19, 0, 0], "debug":[[{"filename":"avg.c", "line":23}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[85, 47, 0, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"avg.c:22", "type":"resource", "data":[457, 359, 0, 1], "debug":[[{"filename":"avg.c", "line":22}]], "children":[{"name":"Floating-point Multiply", "type":"resource", "count":2, "data":[457, 359, 0, 1]}], "replace_name":"true"}, {"name":"avg.c:23", "type":"resource", "data":[92, 272, 1, 0], "debug":[[{"filename":"avg.c", "line":23}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[92, 272, 1, 0], "details":[{"type":"text", "text":"Store uses a Local-pipelined LSU"}]}], "replace_name":"true"}]}]}, {"name":"avg.B5", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[3, 8, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[3, 8, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[3, 2, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Channel Write", "type":"resource", "count":1, "data":[3, 2, 0, 0]}]}]}]}]}]}';
var area_srcJSON='{"max_resources":[109572,219144,514,112],"name":"System","children":[{"debug":[[{"filename":"avg.c","line":8}]],"total_kernel_resources":[3359,3008,3,1],"name":"avg","data":[3359.00003,3008,3,1],"children":[{"detail":[{"text":"Feedback + Cluster logic","type":"text"}],"name":"Data control overhead","type":"resource","data":[983,714,0,0]},{"name":"Component call","type":"resource","data":[0,0,0,0],"details":[{"text":"Stream implemented 128 bits wide with a buffer size of 0 elements.","type":"text"}]},{"name":"Component return","type":"resource","data":[0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"}]},{"name":"Variable: \\n - \'i\' (avg.c:8)","type":"resource","data":[7,36,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}]},{"name":"Variable: \\n - \'j\' (avg.c:8)","type":"resource","data":[40,27,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 16 (depth was increased by a factor of 16 due to a loop initiation interval of 16.)","type":"text"}]},{"name":"Variable: \\n - \'sum\' (avg.c:9)","type":"resource","data":[96,93,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 16 (depth was increased by a factor of 16 due to a loop initiation interval of 16.)","type":"text"}]},{"name":"No Source Line","data":[1289,1285,0,0],"type":"resource","children":[{"count":3,"name":"State","debug":[[{"filename":"","line":0}]],"type":"resource","data":[258,534,0,0]},{"count":1,"debug":[[{"filename":"","line":0}]],"name":"Channel Read","data":[1,0,0,0],"type":"resource"},{"count":1,"name":"Floating-point Add","debug":[[{"filename":"","line":0}]],"type":"resource","data":[995,717,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"","line":0}]],"type":"resource","data":[32,32,0,0]},{"count":1,"debug":[[{"filename":"","line":0}]],"name":"Channel Write","data":[3,2,0,0],"type":"resource"}]},{"replace_name":"true","debug":[[{"filename":"avg.c","line":12}]],"name":"avg.c:12","children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"avg.c","line":12}]],"type":"resource","data":[33,0,0,0]},{"count":2,"name":"6-bit Integer Add","debug":[[{"filename":"avg.c","line":12}]],"type":"resource","data":[4.66667,0,0,0]}],"data":[37.6667,0,0,0],"type":"resource"},{"name":"avg.c:24","debug":[[{"filename":"avg.c","line":24}]],"replace_name":"true","type":"resource","data":[2.33333,0,0,0],"children":[{"count":1,"name":"6-bit Integer Add","debug":[[{"filename":"avg.c","line":24}]],"type":"resource","data":[2.33333,0,0,0]}]},{"name":"avg.c:16","debug":[[{"filename":"avg.c","line":16}]],"replace_name":"true","type":"resource","data":[38,0,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"avg.c","line":16}]],"type":"resource","data":[33,0,0,0]},{"count":2,"name":"4-bit Integer Add","debug":[[{"filename":"avg.c","line":16}]],"type":"resource","data":[5,0,0,0]}]},{"name":"avg.c:18","debug":[[{"filename":"avg.c","line":18}]],"replace_name":"true","type":"resource","data":[33,0,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"avg.c","line":18}]],"type":"resource","data":[33,0,0,0]}]},{"name":"avg.c:19","debug":[[{"filename":"avg.c","line":19}]],"replace_name":"true","type":"resource","data":[35,1,0,0],"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"avg.c","line":19}]],"type":"resource","data":[35,1,0,0]}]},{"name":"avg.c:20","debug":[[{"filename":"avg.c","line":20}]],"replace_name":"true","type":"resource","data":[249,221,2,0],"children":[{"count":1,"name":"Load","debug":[[{"filename":"avg.c","line":20}]],"type":"resource","data":[249,221,2,0]}]},{"name":"avg.c:22","debug":[[{"filename":"avg.c","line":22}]],"replace_name":"true","type":"resource","data":[457,359,0,1],"children":[{"count":2,"name":"Floating-point Multiply","debug":[[{"filename":"avg.c","line":22}]],"type":"resource","data":[457,359,0,1]}]},{"name":"avg.c:23","debug":[[{"filename":"avg.c","line":23}]],"replace_name":"true","type":"resource","data":[92,272,1,0],"children":[{"count":1,"name":"Store","debug":[[{"filename":"avg.c","line":23}]],"type":"resource","data":[92,272,1,0]}]}],"total_percent":[4.09108,3.06556,1.37261,0.583658,0.892857],"type":"function","details":[{"text":"Number of compute units: 1","type":"text"}],"compute_units":1}],"data":[3359.00003,3008,3,1],"total_percent":[4.09108,3.06556,1.37261,0.583658,0.892857],"total":[3359,3008,3,1],"debug_enabled":"true","columns":["","ALUTs","FFs","RAMs","DSPs","Details"],"type":"module"}';
var mavJSON='{"nodes":[{"type":"component", "id":2, "name":"avg", "children":[{"type":"bb", "id":3, "name":"avg.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":4, "name":"avg.B1.start", "children":[{"type":"inst", "id":9, "name":"Channel Read", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"2", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"https://www.altera.com/documentation/mwh1391807516407.html#qah1476410829821"}]}]}]}, {"type":"inst", "id":15, "name":"loop", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"22"}]}, {"type":"inst", "id":16, "name":"end", "details":[{"type":"table", "Start Cycle":"2", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"2", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":5, "name":"avg.B2", "details":[{"type":"table", "Latency":"4", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"20"}]}, {"type":"bb", "id":6, "name":"avg.B3", "children":[{"type":"inst", "id":11, "name":"Load", "debug":[[{"filename":"avg.c", "line":20}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"x", "Start Cycle":"19", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":17, "name":"loop", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"18"}]}, {"type":"inst", "id":18, "name":"loop end", "details":[{"type":"table", "Start Cycle":"69", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"69", "II":"16", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Loop is pipelined with II of 16. See Loops Analysis for more information."}]}, {"type":"bb", "id":7, "name":"avg.B4", "children":[{"type":"inst", "id":12, "name":"Store", "debug":[[{"filename":"avg.c", "line":23}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Start Cycle":"14", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":19, "name":"begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":20, "name":"end", "details":[{"type":"table", "Start Cycle":"46", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"46", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":8, "name":"avg.B5", "children":[{"type":"inst", "id":13, "name":"Channel Write", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Width":"8 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"0", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"https://www.altera.com/documentation/mwh1391807516407.html#qah1476410829821"}]}]}]}, {"type":"inst", "id":21, "name":"begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":22, "name":"loop end", "details":[{"type":"table", "Start Cycle":"1", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"1", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}]}, {"type":"memtype", "id":1, "name":"System Memory", "children":[{"type":"memsys", "id":25, "name":"0", "details":[{"type":"table", "Number of banks":"1", "Arguments from avg":"x, y"}]}]}, {"type":"stream", "id":10, "name":"do", "debug":[[{"filename":"avg.c", "line":7}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"0", "Bits per symbol":"128 bits", "Uses Packets":"No", "Uses Valid":"Yes"}]}, {"type":"stream", "id":14, "name":"return", "debug":[[{"filename":"avg.c", "line":7}]], "details":[{"type":"table", "Width":"8 bits", "Depth":"0", "Bits per symbol":"8 bits", "Uses Packets":"No", "Uses Ready":"Yes"}]}, {"type":"interface", "id":23, "name":"x", "debug":[[{"filename":"avg.c", "line":7}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"avg"}]}, {"type":"interface", "id":24, "name":"y", "debug":[[{"filename":"avg.c", "line":7}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"avg"}]}], "links":[{"from":10, "to":9}, {"from":13, "to":14}, {"from":23, "to":9}, {"from":24, "to":9}, {"from":22, "to":15}, {"from":3, "to":15}, {"from":9, "to":16}, {"from":20, "to":5}, {"from":16, "to":5}, {"from":18, "to":17}, {"from":5, "to":17}, {"from":11, "to":18}, {"from":18, "to":19}, {"from":12, "to":20}, {"from":20, "to":21}, {"from":13, "to":22}, {"from":15, "to":9}, {"from":17, "to":11}, {"from":19, "to":12}, {"from":21, "to":13}, {"from":12, "to":25}, {"from":25, "to":11}]}';
var lmvJSON='{"nodes":[{"type":"interface", "id":23, "name":"x", "debug":[[{"filename":"avg.c", "line":7}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"avg"}]}, {"type":"interface", "id":24, "name":"y", "debug":[[{"filename":"avg.c", "line":7}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"avg"}]}], "links":[]}';
var loopsJSON='{"columns":["", "Pipelined", "II", "Bottleneck", "Details"], "children":[{"name":"Component: avg", "data":["", "", ""], "debug":[[{"filename":"avg.c", "line":7}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}], "children":[{"name":"avg.B1.start", "data":["Yes", ">=1", "n/a"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Run simulation to verify component\'s dynamic II. Use the %L report to view results. II is an approximation due to variable inner loop trip count.", "links":[{"view":"Verification statistics"}]}], "children":[{"name":"avg.B2", "data":["Yes", ">=1", "n/a"], "debug":[[{"filename":"avg.c", "line":12}], [{"filename":"avg.c", "line":12}], [{"filename":"avg.c", "line":24}]], "details":[{"type":"text", "text":"Iteration executed serially across avg.B3. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"avg.c", "line":"20"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"avg.c", "line":"23"}]}]}, {"type":"brief", "text":"Serial exe: Memory dependency"}, {"type":"text", "text":"See %L for more information"}], "children":[{"name":"avg.B3", "data":["Yes", "~16", "II"], "debug":[[{"filename":"avg.c", "line":16}], [{"filename":"avg.c", "line":16}]], "details":[{"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to data dependency on variable(s):", "details":[{"type":"text", "text":"sum (%L)", "links":[{"filename":"avg.c", "line":"9"}]}]}, {"type":"text", "text":"The critical path that prevented successful II = 15 scheduling:", "details":[{"type":"text", "text":"16 clock cycles Floating-point Add Operation (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}]}, {"type":"brief", "text":"Data dependency"}, {"type":"text", "text":"See %L for more information"}], "children":[]}]}]}]}]}';
var summaryJSON='{"estimatedResources":{"name":"Estimated Resource Usage", "columns":["Component Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs "], "children":[{"name":"avg", "data":[3359, 3008, 3, 1], "debug":[[{"filename":"avg.c", "line":7}]]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[3359, 3008, 3, 1], "data_percent":[3.06556, 1.37261, 0.583658, 0.892857]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[109572, 219144, 514, 112]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}}';
var infoJSON='{"name":"Info","rows":[{"name":"Project Name","data":["./a"],"classes":["info-table"]},{"name":"Target Family, Device","data":["Cyclone V, 5CEFA9F23I7"]},{"name":"i++ Version","data":["18.1.0 Build 625"]},{"name":"Quartus Version","data":["18.1.0 Build 625"]},{"name":"Command","data":["i++ -march=CycloneV avg.c -ghdl"]},{"name":"Reports Generated At", "data":["Tue Jul 13 15:48:22 2021"]}]}';
var warningsJSON='{"rows":[]}';
var quartusJSON='{"quartusFitClockSummary":{"name":"Quartus Fit Summary","children":[{"name":"Run Quartus compile to populate this section. See details for more information.","details":[{"type":"text", "text":"This section contains a summary of the area and fmax data generated by compiling the components through Quartus.  To generate the data, run a Quartus compile on the project created for this design. To run the Quartus compile:\\n  1) Change to the quartus directory (./a.prj/quartus)\\n  2) quartus_sh --flow compile quartus_compile\\n"}]}]}}';
var fileJSON=[{"path":"avg.c", "name":"avg.c", "has_active_debug_locs":true, "absName":"d:/FPGA_rtl_project/fir/doc/avg.c", "content":"#include<stdio.h>\012#include<math.h>\012#include<stdlib.h>\012#include \"HLS/hls.h\"\012#define N 32\012component void avg(float* x,float* y)\012{\012  int i, j, k;\012  float sum;\012  float avg;\012\012  for (i = 0; i < N; i++)\012    {\012      sum = 0;\012	  #pragma unroll 1\012      for (j = -2; j <= 2; j++)\012        {\012          k = i + j;\012          if (k >= 0 && k < N)\012            sum += x[k];\012        }\012      avg = sum * 51 / 256;\012      y[i] = avg;\012    }\012}\012\012int main(){\012	float a[N];\012	float b[N];\012	int i=0;\012	srand(3);\012	for(i=0;i<N;i++)\012	{\012		a[i] = rand()%10;\012	}\012	avg(a,b);\012	for(i=0;i<N;i++)\012	{\012		printf(\"a[%d] = %f \\n\",i,a[i]);\012		printf(\"b[%d] = %f \\n\",i,b[i]);\012		printf(\"\\n\");\012	}	\012	return 0;\012}\012"}, {"path":"D:/intelFPGA/18.1/hls/include/HLS/hls.h", "name":"hls.h", "has_active_debug_locs":false, "absName":"d:/intelFPGA/18.1/hls/include/HLS/hls.h", "content":"#ifndef __HLS_H__\012#define __HLS_H__\012\012#ifndef __INTELFPGA_COMPILER__\012#ifndef component\012#define component\012#endif\012#define HLS_X86\012#endif\012\012#include \"HLS/hls_internal.h\"\012\012/* Deprecated APIs and names after intel rebranding */\012#ifdef __IHC_USE_DEPRECATED_NAMES\012#pragma message \"Warning: Enabling deprecated names - these names will not be supported in future releases.\"\012namespace ihc {}\012namespace altera = ihc;\012#define altera_hls_component_run_all ihc_hls_component_run_all\012#define altera_fence ihc_fence\012#define altera_hls_get_sim_time ihc_hls_get_sim_time\012#define altera_hls_enqueue ihc_hls_enqueue\012#define altera_hls_enqueue_noret ihc_hls_enqueue_noret\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012// Memory attributes\012#define hls_register                                  __attribute__((__register__))\012#define hls_memory                                    __attribute__((__memory__))\012#define hls_numbanks(__x)                             __attribute__((__numbanks__(__x)))\012#define hls_bankwidth(__x)                            __attribute__((__bankwidth__(__x)))\012#define hls_singlepump                                __attribute__((__singlepump__))\012#define hls_doublepump                                __attribute__((__doublepump__))\012#define hls_numports_readonly_writeonly(__rd, __wr)   __attribute__((__numports_readonly_writeonly__(__rd, __wr)))\012#define hls_bankbits(__x, ...)                        __attribute__((__bank_bits__(__x, ##__VA_ARGS__)))\012#define hls_merge(__x, __y)                           __attribute__((merge(__x, __y)))\012#define hls_init_on_reset                             __attribute__((__static_array_reset__(1)))\012#define hls_init_on_powerup                           __attribute__((__static_array_reset__(0)))\012#define hls_numreadports(__x)                         __attribute__((__numreadports__(__x)))\012#define hls_numwriteports(__x)                        __attribute__((__numwriteports__(__x)))\012\012// Memory attribute macros\012#define hls_simple_dual_port_memory hls_memory hls_singlepump hls_numports_readonly_writeonly(1,1)\012\012// Interface synthesis attributes\012#define hls_avalon_streaming_component         __attribute__((component_interface(\"avalon_streaming\")))\012#define hls_avalon_slave_component             __attribute__((component_interface(\"avalon_mm_slave\"))) __attribute__((stall_free_return))\012#define hls_always_run_component               __attribute__((component_interface(\"always_run\"))) __attribute__((stall_free_return))\012#define hls_conduit_argument                   __attribute__((argument_interface(\"wire\")))\012#define hls_avalon_slave_register_argument     __attribute__((argument_interface(\"avalon_mm_slave\")))\012#define hls_avalon_slave_memory_argument(__x)  __attribute__((local_mem_size(__x))) __attribute__((slave_memory_argument))\012#define hls_stable_argument                    __attribute__((stable_argument))\012#define hls_stall_free_return                  __attribute__((stall_free_return))\012\012// Component attributes\012#define hls_max_concurrency(__x)               __attribute__((max_concurrency(__x)))\012\012#else\012#define hls_register\012#define hls_memory\012#define hls_numbanks(__x)\012#define hls_bankwidth(__x)\012#define hls_singlepump\012#define hls_doublepump\012#define hls_numports_readonly_writeonly(__rd, __wr)\012#define hls_bankbits(__x, ...)\012#define hls_merge(__x, __y)\012#define hls_init_on_reset\012#define hls_init_on_powerup\012\012#define hls_numreadports(__x)\012#define hls_numwriteports(__x)\012\012#define hls_simple_dual_port_memory\012\012#define hls_avalon_streaming_component\012#define hls_avalon_slave_component\012#define hls_always_run_component\012#define hls_conduit_argument\012#define hls_avalon_slave_register_argument\012#define hls_avalon_slave_memory_argument(__x)\012#define hls_stable_argument\012#define hls_stall_free_return\012\012#define hls_max_concurrency(__x)\012\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Interfaces Declarations\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012\012  ////////////////////////////////\012 /// memory master interface  ///\012////////////////////////////////\012\012template <int n>         class dwidth:public internal::param {};\012template <int n>         class awidth:public internal::param {};\012template <int n>         class latency: public internal::param {};\012template <readwrite_t n> class readwrite_mode: public internal::param{}; // declared in hls_internal.h as enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012template <int n>         class maxburst: public internal::param {};\012template <int n>         class align: public internal::param {};\012template <int n>         class aspace: public internal::param {};\012template <bool n>        class waitrequest: public internal::param{};\012\012template <typename DT, typename p1 = internal::notinit, typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit, typename p6 = internal::notinit, typename p7 = internal::notinit, typename p8 = internal::notinit>\012class mm_master\012#ifdef HLS_X86\012  : public internal::memory_base\012#endif\012{\012public:\012\012#ifdef HLS_X86\012  template<typename T> explicit mm_master(T *data, int size=0, bool use_socket=false):internal::memory_base(data,size,sizeof(DT),use_socket) {\012  }\012#else\012  template<typename T> explicit mm_master(T *data, int size=0, bool use_socket=false);\012#endif\012\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the mm_master object and are only\012  // supported in the testbench:\012  //   mm_master()\012  //   getInterfaceAtIndex()\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the base pointer and should only be used\012  // in the component:\012  //   operator[]()\012  //   operator*()\012  //   operator->()\012  //   operator T()\012  //   operator+()\012  //   operator&()\012  //   operator|()\012  //   operator^()\012  //////////////////////////////////////////////////////////////////////////////\012\012  DT &operator[](int index);\012  DT &operator*();\012  DT *operator->();\012  template<typename T> operator T();\012  DT *operator+(int index);\012  template<typename T> DT *operator&(T value);\012  template<typename T> DT *operator|(T value);\012  template<typename T> DT *operator^(T value);\012  // This function is only supported in the testbench:\012  mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>& getInterfaceAtIndex(int index);\012\012#ifdef HLS_X86\012  // The copy constructor and assignment operator are necessary to ensure\012  // new_masters doesn't get copied.\012  mm_master(const mm_master &other) {\012    mem = other.mem;\012    size = other.size;\012    data_size = other.data_size;\012    use_socket = other.use_socket;\012  }\012  mm_master& operator=(const mm_master& other) {\012    mem = other.mem;\012    size = other.size;\012    data_size = other.data_size;\012    use_socket = other.use_socket;\012  }\012  // Clean up any derrived mm_masters when this object is destroyed.\012  ~mm_master() {\012    for(std::vector<internal::memory_base* >::iterator it = new_masters.begin(),\012        ie = new_masters.end(); it != ie; it++) {\012      delete *it;\012    }\012    new_masters.clear();\012  }\012private:\012  std::vector<internal::memory_base* > new_masters;\012#endif\012\012};\012\012  /////////////////////////////\012 /// streaming interfaces  ///\012//////////////////////////////\012\012template <int n> class buffer:public internal::param {};\012template <int n> class readyLatency:public internal::param {};\012template <int n> class bitsPerSymbol:public internal::param {};\012template <bool b> class usesPackets:public internal::param {};\012template <bool b> class usesValid:public internal::param {};\012template <bool b> class usesReady:public internal::param {};\012\012template <typename T, typename p1 = internal::notinit , typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit>\012class stream_in : public internal::stream<T,p1,p2,p3,p4,p5> {\012public:\012  stream_in();\012  T read();\012  void write(T arg);\012  T tryRead(bool &success);\012  bool tryWrite(T arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setValidCycles(unsigned average_valid, unsigned valid_delta=0);\012};\012\012template <typename T, typename p1 = internal::notinit , typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit>\012class stream_out : public internal::stream<T,p1,p2,p3,p4,p5> {\012\012public:\012  stream_out();\012  T read();\012  void write(T);\012  T tryRead(bool &success);\012  bool tryWrite(T arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setReadyCycles(unsigned average_ready, unsigned ready_delta=0);\012};\012\012}//namespace ihc\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Cosimulation Support API\012////////////////////////////////////////////////////////////////////////////////\012\012#define ihc_hls_enqueue(retptr, func, ...) \\\012  { \\\012    if (__ihc_hls_async_call_capable()){ \\\012      __ihc_enqueue_handle=(retptr); \\\012      (void) (*(func))(__VA_ARGS__); \\\012      __ihc_enqueue_handle=0; \\\012    } else { \\\012      *(retptr) = (*(func))(__VA_ARGS__); \\\012    } \\\012  }\012\012#define ihc_hls_enqueue_noret(func, ...) \\\012  { \\\012  __ihc_enqueue_handle=& __ihc_enqueue_handle; \\\012  (*(func))(__VA_ARGS__); \\\012  __ihc_enqueue_handle=0; \\\012  }\012\012#define ihc_hls_component_run_all(component_address) \\\012  __ihc_hls_component_run_all((void*) (component_address))\012\012// When running a simulation, this function will issue a reset to all components\012// in the testbench\012// Returns: 0 if reset did not occur (ie. if the component target is x86)\012//          1 if reset occured (ie. if the component target is an FPGA)\012extern \"C\" int ihc_hls_sim_reset(void);\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Component Built-Ins\012////////////////////////////////////////////////////////////////////////////////\012\012//Builtin memory fence function call\012#ifdef HLS_X86\012inline void ihc_fence() {};\012\012#else\012extern \"C\" void mem_fence(int);\012inline void ihc_fence() {\012  // fence on all types of fences from OpenCL\012  mem_fence(-1);\012}\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementions, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012#ifdef HLS_X86\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator[](int index) {\012  assert(size==0 || index*data_size<size);\012  return ((DT*)mem)[index];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator*() {\012  return ((DT*)mem)[0];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator->() {\012  return (DT*)mem;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator T() {\012  return (T)((unsigned long long)mem);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator+(int index) {\012  assert(size==0 || index*data_size<size);\012  return &((DT*)mem)[index];\012}\012\012// Bitwise operators\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator&(T value) {\012  return (DT*)((unsigned long long)mem & (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator|(T value) {\012  return (DT*)((unsigned long long)mem | (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator^(T value) {\012  return (DT*)((unsigned long long)mem ^ (unsigned long long)value);\012}\012\012// Function for creating new mm_master at an offset\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>& mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::getInterfaceAtIndex(int index) {\012  assert(size==0 || index*data_size<size);\012  // This new object is cleaned up when this' destructor is called.\012  mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8> *temp = new mm_master(&(((DT*)mem)[index]), size - index * sizeof(DT), use_socket);\012  new_masters.push_back(temp);\012  return *temp;\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012stream_in<T,p1,p2,p3,p4,p5>::stream_in() {}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::read() {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read();\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_in<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::write(T arg) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read(sop, eop);\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_in<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg, sop, eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::setValidCycles(unsigned average_valid, unsigned valid_delta) {\012  if (average_valid == 0) {\012    __ihc_hls_runtime_error_x86(\"The valid average in setValidCycles must be at least 1\");\012  }\012  if (valid_delta > average_valid) {\012    __ihc_hls_runtime_error_x86(\"The valid delta in setValidCycles cannot be larger than the average valid value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(average_valid, valid_delta);\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012stream_out<T,p1,p2,p3,p4,p5>::stream_out() {\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::read() {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read();\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::write(T arg) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_out<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read(sop, eop);\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg, sop, eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_out<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::setReadyCycles(unsigned average_ready, unsigned ready_delta) {\012  if (average_ready == 0) {\012    __ihc_hls_runtime_error_x86(\"The ready average in setReadCycles must be at least 1\");\012  }\012  if (ready_delta > average_ready) {\012    __ihc_hls_runtime_error_x86(\"The ready delta in setReadyCycles cannot be larger than the average ready value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(average_ready, ready_delta);\012}\012#else //fpga path. Ignore the class just return a consistant pointer/reference\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator[](int index) {\012  return ((DT*)this)[index];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator*(){\012  return *((DT*)this);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator->() {\012  return (DT*)this;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator+(int index) {\012  return ((DT*)this)+index;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator T() {\012  return (T)((unsigned long long)this);\012}\012\012// Bitwise operators\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator&(T value) {\012  return (DT*)((unsigned long long)this & (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator|(T value) {\012  return (DT*)((unsigned long long)this | (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator^(T value) {\012  return (DT*)((unsigned long long)this ^ (unsigned long long)value);\012}\012\012#endif\012} // namespace ihc\012\012#endif\012\012"}, {"path":"D:/intelFPGA/18.1/hls/include/HLS/hls_internal.h", "name":"hls_internal.h", "has_active_debug_locs":false, "absName":"d:/intelFPGA/18.1/hls/include/HLS/hls_internal.h", "content":"#ifndef __HLS_INTERNAL_H__\012#define __HLS_INTERNAL_H__\012\012#ifdef HLS_X86\012#include <queue>\012#include <string.h> //memcpy\012#include <assert.h>\012#endif\012#include <stdio.h>\012#include <stdlib.h>\012\012#if defined(__clang__) //our llvm defines _MSC_VER so check this first\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#elif defined(_MSC_VER)\012  #define WINDOWSWEAK __declspec(selectany)\012  #define LINUXWEAK\012#else\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#endif\012\012WINDOWSWEAK void *__ihc_enqueue_handle LINUXWEAK;\012\012extern \"C\" unsigned long long ihc_hls_get_sim_time(void);\012extern \"C\" int __ihc_hls_get_clock_period_ps(void);\012extern \"C\" int __ihc_hls_component_start_sim_task(const char *component_name);\012extern \"C\" int __ihc_hls_component_wait_sim_task(const char *component_name);\012extern \"C\" void __ihc_hls_stream_sink_wait_sim_task(void* obj_ptr);\012extern \"C\" void __ihc_hls_component_run_all(const void* component_address);\012\012// Cosim internal support calls\012extern \"C\" int __ihc_hls_async_call_capable(void);\012// Print error message and bail\012extern \"C\" void __ihc_hls_runtime_error(const char *msg);\012inline void __ihc_hls_runtime_error_x86(const char *msg){\012  printf(\"Error: %s\\n\",msg);\012  exit(1);\012}\012\012enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012\012namespace ihc {\012// Forward declarations so I can make them friends\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8> class mm_master;\012template <typename T, typename p1, typename p2, typename p3, typename p4, typename p5> class stream_in;\012template <typename T, typename p1, typename p2, typename p3, typename p4, typename p5> class stream_out;\012\012namespace internal {\012\012\012// Interface parameter base types used to define interfaces\012class param {};\012class notinit:public param {};\012\012class memory_base {\012private:\012#ifdef HLS_X86\012  // Attributes\012  int aspace; \012  int awidth;\012  int dwidth;\012  int latency;\012  readwrite_t readwrite_mode;\012  bool byteenabled;\012  int maxburst;\012  int align;\012  bool waitrequest;\012  \012  size_t sim_base;\012  // Extra cosim book keeping\012  size_t data_size; //size of the underlying type used by the interface\012  void *mem;\012  size_t size;\012  bool use_socket; // if true, all reads and writes will go through the IPC socket instead of shared memory\012\012  //Make sure only the listed classes can reach the destructor, and nothing derived from them\012  ~memory_base() {}; // Cannot inherit from HLS interface\012  template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8> friend class ::ihc::mm_master;\012\012  //description of test data buffer accessed through this interface\012  void set_mem(void *x) {mem=x;};\012  void set_size(size_t x) {size=x;};\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  \012#endif\012public:\012#ifdef HLS_X86\012  memory_base() {}\012  memory_base(void *mem, size_t size, size_t data_size, bool use_socket):data_size(data_size),mem(mem),size(size),use_socket(use_socket) {}\012  memory_base(int aspace, int awidth, int dwidth,  int latency, readwrite_t readwrite_mode, bool byteenabled, int maxburst, int align, bool waitrequest );\012\012  void set_parameters(int aspace, int awidth, int dwidth,  int latency, readwrite_t readwrite_mode, bool byteenabled, int maxburst, int align, bool waitrequest );\012  void set_base(void *ptr, size_t datasize, size_t size, bool use_socket);\012  int get_interface_aspace() {return aspace;}\012  void * get_base(){return mem;}\012  size_t get_size() {return size;}\012  int get_awidth() {return awidth;}\012  int get_dwidth() {return dwidth;}\012  int get_latency() {return latency;}\012  readwrite_t get_readwrite_mode() {return readwrite_mode;}\012  bool get_byteenabled() {return byteenabled;}\012  int get_maxburst() {return maxburst;}\012  int get_align() {return align;}\012  bool get_waitrequest() {return waitrequest;}\012  \012  size_t get_data_size() {return data_size;}\012\012  void set_sim_base(size_t addr) {sim_base = addr;}\012  size_t get_sim_base() {return sim_base;}\012  \012  void set_use_socket(bool socket) {use_socket = socket;}\012  bool uses_socket() {return use_socket;}\012#endif\012};\012\012#ifdef HLS_X86\012class stream_abstract_base {\012  bool stable; // does the data on this interface change between function calls?\012  bool implicit; // is this interface synchronous with the component's function call interface?\012  bool global; // is this an implicit interface that carries a global variable's address?\012  size_t data_size; //size of the underlying type used by the interface\012protected:\012  unsigned m_average_stall;\012  unsigned m_stall_delta;\012  unsigned m_average_RoV;\012  unsigned m_RoV_delta;\012  unsigned m_remaining_period;\012  unsigned m_period_threshold;\012public:\012stream_abstract_base():stable(false), implicit(false), global(false), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1) { assert(1==0);}\012stream_abstract_base(size_t data_size):stable(false), implicit(false), global(false), data_size(data_size), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1){}\012  bool is_stable() {return stable;}\012  void set_stable() {stable = true;}\012  bool is_implicit() {return implicit;}\012  bool is_global() {return global;}\012  void set_implicit() {implicit = true;}\012  void set_global() {global = true;}\012  size_t get_data_size() {return data_size;}\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  unsigned get_average_stall() {return m_average_stall;}\012  unsigned get_stall_delta() {return m_stall_delta;}\012  unsigned get_average_RoV() {return m_average_RoV;}\012  unsigned get_RoV_delta() {return m_RoV_delta;}\012  virtual bool _internal_cosim_empty() = 0;\012  virtual void read_by_ptr(void *data) = 0;\012  virtual void read_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void write_by_ptr(void *data) = 0;\012  virtual void write_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void front_by_ptr(void *data) = 0;\012  virtual void front_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual size_t get_size() = 0;\012};\012#endif\012\012template<typename T, typename p1 = notinit, typename p2 = notinit, typename p3 = notinit, typename p4 = notinit, typename p5 = notinit>\012class stream \012#ifdef HLS_X86\012  :  public stream_abstract_base \012#endif\012{\012   ~stream() {} // Cannot inherit from HLS interface\012  //Make sure only the listed classes can reach the destructor, and nothing derived from them\012  template <typename T1, typename p11, typename p21, typename p31, typename p41, typename p51> friend class ihc::stream_in;\012  template <typename T1, typename p11, typename p21, typename p31, typename p41, typename p51> friend class ihc::stream_out;\012\012#ifdef HLS_X86\012  std::queue<T> q_;\012  std::queue<std::pair<bool,bool> > qp_;\012#endif\012  \012protected:\012  stream();\012  \012#ifdef HLS_X86\012  stream(const stream<T,p1,p2,p3,p4,p5>& copy_from);\012#endif\012  \012public:     \012  bool _internal_cosim_empty(); \012#ifdef HLS_X86\012  virtual T read();               \012  virtual void write(T arg);      \012  virtual T tryRead(bool &success);   \012  virtual bool tryWrite(T arg);       \012\012  // for packet based stream \012  virtual T read(bool& sop, bool& eop);\012  virtual void write(T arg, bool sop, bool eop);\012  virtual T tryRead(bool &success, bool& sop, bool& eop);\012  virtual bool tryWrite(T arg, bool sop, bool eop);     \012  virtual void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  virtual void setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta=0);\012#else\012  T read();               \012  void write(T arg);      \012  T tryRead(bool &success); \012  bool tryWrite(T arg);       \012\012  // for packet based stream \012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);     \012#endif\012   T _internal_cosim_front();\012   T _internal_cosim_front(bool& sop, bool& eop);\012  \012#ifdef HLS_X86\012  void read_by_ptr(void *data);\012  void read_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void write_by_ptr(void *data);\012  void write_by_ptr_pkt(void *data, bool* sop, bool*eop);\012  void front_by_ptr(void *data);\012  void front_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  size_t get_size() {return q_.size();}\012\012  // control stall/valid behaviour\012  bool stall();\012  void setStallPeriod();\012  //Middle Square Weyl Sequence RNG\012   unsigned msws();\012#endif\012};\012\012template <typename T, typename p1 , typename p2, typename p3, typename p4, typename p5>\012  stream<T,p1,p2,p3,p4,p5>::stream()\012#ifdef HLS_X86\012 :stream_abstract_base(sizeof(T))\012#endif\012{\012}\012#ifdef HLS_X86\012template <typename T, typename p1 , typename p2, typename p3, typename p4, typename p5>\012  stream<T,p1,p2,p3,p4,p5>::stream(const stream<T,p1,p2,p3,p4,p5>& copy_from):stream_abstract_base(sizeof(T)),q_(copy_from.q_),qp_(copy_from.qp_)\012{\012}\012#endif\012\012  ////////////////\012 /// stream   ///\012////////////////\012\012#ifdef HLS_X86\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty() {\012  bool empty=q_.empty();  \012  return empty;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read(sop,eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::read() {\012  T arg;      \012  \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  q_.pop();\012  qp_.pop(); //unused sideband signals\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012  T arg;\012\012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  q_.pop();\012  std::pair<bool,bool> p = qp_.front();\012  qp_.pop(); //unused sideband signals\012  \012  sop = p.first;\012  eop = p.second;\012\012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::_internal_cosim_front() {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::_internal_cosim_front(bool& sop, bool& eop) {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012\012  sop = p.first;\012  eop = p.second;\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg);\012   }\012   return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg, sop, eop);\012   }\012   return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write(T arg) {\012    q_.push(arg);\012    qp_.push(std::pair<bool,bool>(false,false)); // sideband signals\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    q_.push(arg);\012    qp_.push(std::pair<bool,bool>(sop, eop)); // sideband signals\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::read_by_ptr(void *data) {\012    T elem = read();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::read_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = read(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::front_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = _internal_cosim_front(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));    \012}\012\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::front_by_ptr(void *data) {\012    T elem = _internal_cosim_front();\012    memcpy(data, &elem, sizeof(T));    \012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem, *sop, *eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write_by_ptr(void *data) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::setStallPeriod() {\012    if (m_stall_delta == 0) {\012        m_remaining_period = m_average_stall;\012    } else {\012        m_remaining_period = (m_average_stall - m_stall_delta) + msws()%(m_stall_delta*2+1);\012    }\012    if (m_RoV_delta == 0) {\012        m_period_threshold = m_average_RoV;\012    } else {\012        m_period_threshold = (m_average_RoV - m_RoV_delta) + msws()%(m_RoV_delta*2+1);\012    }\012    m_remaining_period +=  m_period_threshold;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012  void stream<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012    m_average_stall = average_stall;\012    m_stall_delta = stall_delta;\012    setStallPeriod();\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012  void stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta) {\012    m_average_RoV = average_RoV;\012    m_RoV_delta = RoV_delta;\012    setStallPeriod();\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::stall() {\012  if (m_remaining_period > 0) {\012    m_remaining_period--;\012    if (m_remaining_period < m_period_threshold) { \012      return false;\012    } else {\012      return true;\012    }\012  }\012  setStallPeriod();\012  return false;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012unsigned stream<T,p1,p2,p3,p4,p5>::msws() {\012  static unsigned long long x = 0, w = 0;\012  const unsigned long long s = 0xb5ad4eceda1ce2a9ULL;\012  \012  x *= x; \012  x += (w += s); \012  return (unsigned) (x = (x>>32) | (x<<32));\012}\012\012#endif\012} //namespace internal\012} //namespace ihc\012\012#endif\012\012"}];